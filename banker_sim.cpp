#include <iostream>
#include <cstdlib>
using namespace std;

#define SUSPENDED	0
#define ACTIVE		1
#define TERMINATED	2

struct state
{
	int resource[100];
	int claim[100][100];
	int alloc[100][100];
	int available[100];
}real,temp;



struct Processes{
	int state;
	int time;
} allProcesses[100];



bool exceedsAvailable(int request[], int available[], int r){
 	for (int j = 0; j < r; ++j)
 	{
 		if(request[j] > available[j])
 			return true;
 	}
 	return false;
}

int performRequest(int r, int p){
	//cout<<"Perform request"<<endl;
	/*generation of the request*/
	//choose one od the processes
	cout<<"( [";
	int	randomP = rand()%p;
	cout<<randomP<<"], ";
	int request[r]; 	//request generated by the randomly choosen process
	for (int j = 0; j < r; ++j)
	{
		if(real.claim[randomP][j] - real.alloc[randomP][j] != 0)
			request[j] = rand()%(real.claim[randomP][j] - real.alloc[randomP][j]);
		else
			request[j] = 0;
		cout<<request[j]<<", ";
	}
	cout<<")"<<endl;
	/**************************/	



	if(exceedsAvailable(request, real.available, r)){
		allProcesses[randomP].state = SUSPENDED;
	}else{
		for (int j = 0; j < r; ++j)
		{
			real.alloc[randomP][j] += request[j];
			real.available[j] -= request[j];
		}
	}
	return randomP;
}

void saveState(int r, int p)
{
	//cout<<"saving state"<<endl;
	for(int i=0;i<r;i++)
	{	
		temp.resource[i]=real.resource[i];
		temp.available[i]=real.available[i];
	}	
	for(int i=0;i<p;i++)
	{
		for(int j=0;j<r;j++)
		{
			temp.alloc[i][j]=real.alloc[i][j];
			temp.claim[i][j]=real.claim[i][j];

		}
	}
}

// bool isSafe(int r,int p)
// {
// 	bool check = false;
// 	for(int i=0;i<p;i++)
// 	{
// 			for(int j=0;j<r;j++)
// 			{
// 				if(real.claim[i][j]-real.alloc[i][j]<=real.available[j])
// 					check=true;
// 				else{
// 					check=false;
// 					break;
// 				}
// 			}
// 			if(check)
// 				return check;
// 	}

// 	return false;
// }


//returns if current real state can go to completion without deadlock
bool isSafe(int r, int p){
//	cout<<"Checking if current state is safe"<<endl;
	int count = p;
	bool picked[p];
	for (int i = 0; i < p; ++i)
	{
		picked[i] = false;
	}
	while(count!=0){
		bool safe = false;
		//check if the next step is possible
		for (int i = 0; i < p; ++i)
		{
			if(picked[i] != true){
				int resRequired[r];
				for (int j = 0; j < r; ++j)
				{
					resRequired[j] = real.claim[i][j] - real.alloc[i][j];
				}
				if(! exceedsAvailable(resRequired, real.available, r)){
					safe = true;
					picked[i] = true;
					for (int j = 0; j < r; ++j)
					{
						real.available[j] += real.alloc[i][j];
					} 
					count--;
					break;
				}

			}	
		}
		if(!safe){
			return false;
		}
	}
	return true;
}



void restoreState(int r,int p)
{

	for(int i=0;i<r;i++)
	{	
		real.resource[i]=temp.resource[i];
		real.available[i]=temp.available[i];
	}	
	for(int i=0;i<p;i++)
	{
		for(int j=0;j<r;j++)
		{
			real.alloc[i][j]=temp.alloc[i][j];
			real.claim[i][j]=temp.claim[i][j];

		}
	}

}


void initialState(int r, int p){
	for (int i = 0; i < p; ++i)
	{
		allProcesses[i].state = ACTIVE;
	}
	cout<<"Enter the resource(R) vector\n";
	for(int i=0;i<r;i++)
		cin >> real.resource[i];
	
	cout<<"Enter Claim(C) matrix\n";
	for(int i=0;i<p;i++){
		for (int j = 0; j < r; ++j)
		{
			cin>>real.claim[i][j];
		}
	}
	for (int i = 0; i < p; ++i)
	{
		for (int j = 0; j < r; ++j)
		{
			real.alloc[i][j] = 0;
		}
	}

	for (int j = 0; j < r; ++j)
	{
		real.available[j] = real.resource[j];
	}
}

bool satisfied(int pid, int r){
	for (int j = 0; j < r; ++j)
	{
		if(real.alloc[pid][j] != real.claim[pid][j])
		{
			return false;
		}
	}
	return true;
}

int main(){
	
	int t=0, p, r, Time;
	cout<<"Enter the amount of time to simulate\n";
	cin>>Time;
	cout<<"Enter number of process(p) to simulate\n";
	cin>>p;
	cout<<"Enter number(r) of resources\n";
	cin>>r;
	
	initialState(r,p);
	int pid;
	while(t<Time){
		saveState(r,p);
		pid  = performRequest(r, p);
		if(!isSafe(r,p)){
			allProcesses[pid].state = SUSPENDED;
			restoreState(r,p);
		}else{
			if(satisfied(pid,r)){
				for (int j = 0; j < r; ++j)
				{
					real.available[j] += real.claim[pid][j];
				}
				allProcesses[pid].state = TERMINATED;
			}
		}
		t++;

	}
	for (int i = 0; i < p; ++i)
	{
		for (int j = 0; j < Time; ++j)
		{
			cout<<allProcesses[i].state;
		}	
		cout<<endl;			
	}
	return 0;
}